<!DOCTYPE html>
<html>
  <head>
    <title>DB48x</title>
    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=0.9, maximum-scale=1.0" />
    <link rel="manifest" href="manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <link rel="apple-touch-icon" href="./logo.png">
    <script src="./main.js"></script>
    <style>
      html, body {
        padding: 0;
        margin: auto auto;
        background-color: black;
        overflow: hidden; 
        display: flex;
        height: 100vh;
        width: 100vw;
        flex-direction: row;
        align-items: center; 
        justify-items: center;
        -webkit-user-select: none; /* Safari */
        -ms-user-select: none; /* IE 10 and IE 11 */
        user-select: none; /* Standard syntax */
      }

      canvas {
        display: block;
        margin: 0 auto;
      }

      #keyCanvas {
        background-image: url('keyboard-db48x.png');
        background-repeat: no-repeat;
        background-size: 100% 100%;
        margin: 0 auto;
        align-self: center;
        width: 100%;
      }

      #lcdCanvas {
        align-self: center;
        width: 100%;
        /* IE, only works on <img> tags */
        -ms-interpolation-mode: nearest-neighbor;
        /* Firefox */
        image-rendering: crisp-edges;
        /* Chromium + Safari */
        image-rendering: pixelated;
      }
      #calcContainer {
        margin: auto;
        grid-column: 1 / 1;
        grid-row: 2;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-items: center;
        padding-bottom: 15%;
      }   

    </style>
  </head>
  <body>
    <div id="calcContainer">
      <canvas id="lcdCanvas"></canvas>
      <canvas id="keyCanvas"></canvas>
    </div>

<script>

    // disable scrolling
    document.getElementsByTagName('body')[0].onscroll = function(event) {
      event.preventDefault();
    };

    // parse URL for any attributes
    const params = new URLSearchParams(window.location.search);
    const mode = params.get('mode');

    // change the kb image based on the mode
    if (mode) {
      let kc = document.getElementById("keyCanvas");
      if (kc) {
        // console.log("mode: ", mode);
        kc.style.setProperty("background-image", "url('keyboard-dm42-lrg.png')");
      }
    }

    // toggle keyboard via double tap
    document.getElementById('lcdCanvas').ondblclick = function(event) {
      event.preventDefault();
      let kc = document.getElementById("keyCanvas");
      if (kc) {
        // fetch the current background image
        let kbtype = kc.style.getPropertyValue("background-image");
        if (kbtype.includes("dm42")) {
          kc.style.setProperty("background-image", "url('keyboard-db48x.png')");
        } else {
          kc.style.setProperty("background-image", "url('keyboard-dm42-lrg.png')");
        }
      }
    };    

    // globals
    const DEBUG = false;
    const SIM_LCD_H = 240; // Height of the LCD
    const SIM_LCD_SCANLINE = 416; // Width of the LCD scanline
    const SIM_LCD_OFFSET = 16;
    const BPP = 1; // Bits per pixel
    const WORD_SIZE = 32; // Size of the word in bits
    const MASK = (1 << BPP) - 1; // Mask to extract BPP bits
    const KB_RATIO = 1.3; // Keyboard aspect ratio
    let keyBuffer = []; // keyBuffer
    let threadSince = 0;
    let threadInterval = 50; // 50ms
    let threadCanvas;

    // Keyboard mapping with key areas
    const key_map_ = [
            [ 38, 0.03,  0.15,  0.03,  0.10  ], // Qt::Key_F1,      
            [ 39, 0.20,  0.32,  0.03,  0.10  ], // Qt::Key_F2,      
            [ 40, 0.345, 0.47,  0.03,  0.10  ], // Qt::Key_F3,      
            [ 41, 0.52,  0.63,  0.03,  0.10  ], // Qt::Key_F4,      
            [ 42, 0.68,  0.80,  0.03,  0.10  ], // Qt::Key_F5,      
            [ 43, 0.83,  0.95,  0.03,  0.10  ], // Qt::Key_F6,      
        
            [  1, 0.03,  0.15,  0.15,  0.22  ], // Qt::Key_A,       
            [  2, 0.20,  0.32,  0.15,  0.22  ], // Qt::Key_B,       
            [  3, 0.345, 0.47,  0.15,  0.22  ], // Qt::Key_C,       
            [  4, 0.52,  0.63,  0.15,  0.22  ], // Qt::Key_D,       
            [  5, 0.68,  0.80,  0.15,  0.22  ], // Qt::Key_E,       
            [  6, 0.83,  0.95,  0.15,  0.22  ], // Qt::Key_F,       
        
            [  7, 0.03,  0.15,  0.275, 0.345 ], // Qt::Key_G,       
            [  8, 0.20,  0.32,  0.275, 0.345 ], // Qt::Key_H,       
            [  9, 0.345, 0.47,  0.275, 0.345 ], // Qt::Key_I,       
            [ 10, 0.52,  0.63,  0.275, 0.345 ], // Qt::Key_J,       
            [ 11, 0.68,  0.80,  0.275, 0.345 ], // Qt::Key_K,       
            [ 12, 0.83,  0.95,  0.275, 0.345 ], // Qt::Key_L,       
        
            [ 13, 0.03,  0.32,  0.40,  0.47  ], // Qt::Key_Return,  
            [ 14, 0.345, 0.47,  0.40,  0.47  ], // Qt::Key_M,       
            [ 15, 0.51,  0.64,  0.40,  0.47  ], // Qt::Key_N,       
            [ 16, 0.68,  0.80,  0.40,  0.47  ], // Qt::Key_O,       
            [ 17, 0.83,  0.95,  0.40,  0.47  ], // Qt::Key_Backspace
        
            [ 18, 0.03,  0.15,  0.52,  0.59  ], // Qt::Key_Up,      
            [ 19, 0.23,  0.36,  0.52,  0.59  ], // Qt::Key_7,       
            [ 20, 0.42,  0.56,  0.52,  0.59  ], // Qt::Key_8,       
            [ 21, 0.62,  0.75,  0.52,  0.59  ], // Qt::Key_9,       
            [ 22, 0.81,  0.95,  0.52,  0.59  ], // Qt::Key_Slash,   
        
            [ 23, 0.03,  0.15,  0.645, 0.715 ], // Qt::Key_Down,    
            [ 24, 0.23,  0.36,  0.645, 0.715 ], // Qt::Key_4,       
            [ 25, 0.42,  0.56,  0.645, 0.715 ], // Qt::Key_5,       
            [ 26, 0.62,  0.75,  0.645, 0.715 ], // Qt::Key_6,       
            [ 27, 0.81,  0.95,  0.645, 0.715 ], // Qt::Key_Asterisk,
        
            [ 28, 0.028, 0.145, 0.77,  0.84  ], // Qt::Key_Control, 
            [ 29, 0.23,  0.36,  0.77,  0.84  ], // Qt::Key_1,       
            [ 30, 0.42,  0.56,  0.77,  0.84  ], // Qt::Key_2,       
            [ 31, 0.62,  0.75,  0.77,  0.84  ], // Qt::Key_3,       
            [ 32, 0.81,  0.95,  0.77,  0.84  ], // Qt::Key_Minus,   
        
            [ 33, 0.03,  0.15,  0.89,  0.97  ], // Qt::Key_Escape,  
            [ 34, 0.23,  0.36,  0.89,  0.97  ], // Qt::Key_0,       
            [ 35, 0.42,  0.55,  0.89,  0.97  ], // Qt::Key_Period,  
            [ 36, 0.62,  0.74,  0.89,  0.97  ], // Qt::Key_Question,
            [ 37, 0.81,  0.95,  0.89,  0.97  ], // Qt::Key_Plus,    
        ];

        const keystroke_map = {
          "0": 34,
          "1": 29,
          "2": 30,
          "3": 31,
          "4": 24,
          "5": 25,
          "6": 26,
          "7": 19,
          "8": 20,
          "9": 21,
          ".": 35,
          "+": 37,
          "-": 32,
          "*": 27,
          "/": 22,
          "'": 6,
          "=": 36,
          " ": 36,
          "`": 1,
          "Alt": 1,
          "Meta": 1,
          "Enter": 13,
          "Backspace": 17,
          "Escape": 33,
          "F1": 38,
          "F2": 39,
          "F3": 40,
          "F4": 41,
          "F5": 42,
          "F6": 43,
          "Up": 18,
          "Down": 23,
          "Shift": 28,
          "Control": 28,
          "a": 1,
          "b": 2,
          "c": 3,
          "d": 4,
          "e": 5,
          "f": 6,
          "g": 7,
          "h": 8,
          "i": 9,
          "j": 10,
          "k": 11,
          "l": 12,
          "m": 14,
          "n": 15,
          "o": 16,
          "p": 36,
          "q": 20,
          "r": 21,
          "s": 22,
          "t": 24,
          "u": 25,
          "v": 26,
          "w": 27,
          "x": 29,
          "y": 30,
          "z": 31,
          "ArrowLeft": 18,
          "ArrowRight": 23,
          "ArrowUp": 18,
          "ArrowDown": 23,
        };

        let key_map = [];

        // we create a keymap that is slightly larger than the actual original keymap
        // this helps with the touch events
        for (let i=0; i<key_map_.length; i++) {
          let offset = 0.015;
          key_map.push([key_map_[i][0], key_map_[i][1]-offset, key_map_[i][2]+offset, key_map_[i][3]-offset, key_map_[i][4]+offset]);
        }

        // canvas for the keyboard
        const canvas_key = document.getElementById('keyCanvas');
        const KEY_H = SIM_LCD_SCANLINE * KB_RATIO;
        const KEY_W = SIM_LCD_SCANLINE - SIM_LCD_OFFSET;
        canvas_key.width  = KEY_W;
        canvas_key.height = KEY_H;
        const ctx_key = canvas_key.getContext('2d');        
        ctx_key.clearRect( 0, 0, KEY_W, KEY_H);
        // debug presses
        if (DEBUG) {
          ctx_key.strokeStyle = "red";
          for (let i=0; i<key_map.length; i++) {
            ctx_key.beginPath();
            ctx_key.moveTo(key_map[i][1]*KEY_W, key_map[i][3]*KEY_H);
            ctx_key.lineTo(key_map[i][1]*KEY_W, key_map[i][4]*KEY_H);
            ctx_key.lineTo(key_map[i][2]*KEY_W, key_map[i][4]*KEY_H);
            ctx_key.lineTo(key_map[i][2]*KEY_W, key_map[i][3]*KEY_H);
            ctx_key.lineTo(key_map[i][1]*KEY_W, key_map[i][3]*KEY_H);
            ctx_key.stroke();
          }
        }

        const drawKey = function(key) {
          const ctx_key = canvas_key.getContext('2d');        
          if (threadCanvas) {
            clearTimeout(threadCanvas);
            ctx_key.clearRect( 0, 0, KEY_W, KEY_H);
          }
          ctx_key.strokeStyle = "#fcd34e";
          ctx_key.beginPath();
            ctx_key.moveTo(key_map[key][1]*KEY_W, key_map[key][3]*KEY_H);
            ctx_key.lineTo(key_map[key][1]*KEY_W, key_map[key][4]*KEY_H);
            ctx_key.lineTo(key_map[key][2]*KEY_W, key_map[key][4]*KEY_H);
            ctx_key.lineTo(key_map[key][2]*KEY_W, key_map[key][3]*KEY_H);
            ctx_key.lineTo(key_map[key][1]*KEY_W, key_map[key][3]*KEY_H);
            ctx_key.stroke();
            threadCanvas = setTimeout(() => {
              ctx_key.clearRect( 0, 0, KEY_W, KEY_H);
            }, 500);
          }

        // get the mouse/touch position
        const getMousePosition = function(canvas, event) {
            let rect = canvas.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;
            if (DEBUG) {
              console.log("clicked x: " + x, " y: " + y);
            }
            // should use html elements for the keys in future
            for (let i=0; i<key_map.length; i++) {
              if (x > key_map[i][1]*KEY_W && x < key_map[i][2]*KEY_W && y > key_map[i][3]*KEY_H && y < key_map[i][4]*KEY_H) {
                if (DEBUG) {
                  console.log("clicked:", key_map[i][0]);
                }
                keyBuffer.push(key_map[i][0]);
                drawKey(i);
              }
            }
        }

        const processKey = function() {
          if (keyBuffer.length > 0) {
                let key = keyBuffer.shift(); 
                if (DEBUG) {
                  console.log("processed key:", key);
                }
                Module.ui_push_key(key);
                Module.ui_push_key(0);
                }
        } 
        
        // add an event listener to the canvas so we can parse the key presses
        canvas_key.addEventListener("mousedown", function (e) {
            getMousePosition(canvas_key, e);
        }); 

        // add an event listener to the canvas so we can parse the key presses
        document.addEventListener("keyup", (event)=>{
          // check that event.key matches a key in the keystroke_map
          if (Object.keys(keystroke_map).includes(event.key)) {
            keyBuffer.push(keystroke_map[event.key]);
          } else {
            if (DEBUG) {
              console.log("Key not found in keystroke_map: ", event.key);
            }
          }
        });

        // draw the LCD panel
        const canvas = document.getElementById('lcdCanvas');
        canvas.width = SIM_LCD_SCANLINE - SIM_LCD_OFFSET;
        canvas.height = SIM_LCD_H;
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(canvas.width, canvas.height);

        // parse the LCD data and draw to the canvas
        const drawBitmap = function(canvasId, dataArray, width, height) {
          const canvas = document.getElementById(canvasId);
          const ctx = canvas.getContext('2d');
          
          canvas.width = SIM_LCD_SCANLINE - SIM_LCD_OFFSET;
          canvas.height = SIM_LCD_H;
          
          const imageData = ctx.createImageData(width, height);
          const data = imageData.data;

          for (let i = 0; i < dataArray.length; i++) {
              const bitmask = dataArray[i];
              for (let bit = 0; bit < 32; bit++) {
                  const value = (bitmask >> bit) & 1;
                  const pixelIndex = i * 32 + bit;
                  const x = pixelIndex % width;
                  const y = Math.floor(pixelIndex / width);
                  const mirroredX = width - 1 - x; // Mirroring the x position
                  const index = (y * width + mirroredX) * 4;
                  // const index = (y * width + x) * 4;

                  const color = value === 1 ? 213 : 0;
                  data[index] = color;
                  data[index + 1] = color;
                  data[index + 2] = color;
                  data[index + 3] = 255; // Alpha channel
              }
          }

          // offset -16 pixels to the left
          ctx.putImageData(imageData, -SIM_LCD_OFFSET, 0);
        }

      
      Module.onRuntimeInitialized = function() {

        // initialise the calculator
        console.log("loaded wasm...");
        console.log("init_all_elements()",Module.init_all_elements());

        // fetch and display the LCD
        const getLCD = function() {
          var heap = Module.updatePixmap();
          const lcd_buffer = []
          for (let v=0; v < (13*240); v++) {
            lcd_buffer.push( Module.HEAP32[heap/Int32Array.BYTES_PER_ELEMENT+v] )
          }
          drawBitmap('lcdCanvas', lcd_buffer, SIM_LCD_SCANLINE, SIM_LCD_H);
        }

        // thread to draw the LCD and run the calculator
        const drawThread = function() {
          let now = new Date().getTime();
          let dt = now - threadSince;  
          processKey();
          if (dt > threadInterval) {
            Module.run_rpl();
            getLCD();
            threadSince = now;
          }
          window.requestAnimationFrame(drawThread);
        }

        window.requestAnimationFrame(drawThread);

        
      }
    </script>

  </body>
</html>
