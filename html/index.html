<!DOCTYPE html>
<html>
  <head>
    <title>DB48x</title>
    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=0.9, maximum-scale=1.0" />
    <link rel="manifest" href="manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <link rel="apple-touch-icon" href="./logo.png">
    <script src="./main.js"></script>
    <style>
      html, body {
        padding: 0;
        margin: auto auto;
        background-color: black;
        overflow: hidden; 
        display: flex;
        height: 100vh;
        width: 100vw;
        flex-direction: row;
        align-items: center; 
        justify-items: center;
      }

      canvas {
        display: block;
        margin: 0 auto;
      }

      #keyCanvas {
        background-image: url('keyboard-db48x.png');
        background-repeat: no-repeat;
        background-size: 100% 100%;
        margin: 0 auto;
        align-self: center;
        width: 100%;
      }

      #lcdCanvas {
        align-self: center;
        width: 100%;
        /* IE, only works on <img> tags */
        -ms-interpolation-mode: nearest-neighbor;
        /* Firefox */
        image-rendering: crisp-edges;
        /* Chromium + Safari */
        image-rendering: pixelated;
      }
      #calcContainer {
        margin: auto;
        grid-column: 1 / 1;
        grid-row: 2;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-items: center;
      }   

    </style>
  </head>
  <body>
    <div id="calcContainer">
      <canvas id="lcdCanvas"></canvas>
      <canvas id="keyCanvas"></canvas>
    </div>

<script>
    document.getElementsByTagName('body')[0].onscroll = function(event) {
      event.preventDefault();
    };
    
    const DEBUG = false;
    const SIM_LCD_H = 240; // Height of the LCD
    const SIM_LCD_SCANLINE = 416; // Width of the LCD scanline
    const SIM_LCD_OFFSET = 16;
    const BPP = 1; // Bits per pixel
    const WORD_SIZE = 32; // Size of the word in bits
    const MASK = (1 << BPP) - 1; // Mask to extract BPP bits
    const KB_RATIO = 1.3; // Keyboard aspect ratio

    // Keyboard mapping with key areas
    const key_map = [
            [ 38, 0.03,  0.15,  0.03,  0.10  ], // Qt::Key_F1,      
            [ 39, 0.20,  0.32,  0.03,  0.10  ], // Qt::Key_F2,      
            [ 40, 0.345, 0.47,  0.03,  0.10  ], // Qt::Key_F3,      
            [ 41, 0.52,  0.63,  0.03,  0.10  ], // Qt::Key_F4,      
            [ 42, 0.68,  0.80,  0.03,  0.10  ], // Qt::Key_F5,      
            [ 43, 0.83,  0.95,  0.03,  0.10  ], // Qt::Key_F6,      
        
            [  1, 0.03,  0.15,  0.15,  0.22  ], // Qt::Key_A,       
            [  2, 0.20,  0.32,  0.15,  0.22  ], // Qt::Key_B,       
            [  3, 0.345, 0.47,  0.15,  0.22  ], // Qt::Key_C,       
            [  4, 0.52,  0.63,  0.15,  0.22  ], // Qt::Key_D,       
            [  5, 0.68,  0.80,  0.15,  0.22  ], // Qt::Key_E,       
            [  6, 0.83,  0.95,  0.15,  0.22  ], // Qt::Key_F,       
        
            [  7, 0.03,  0.15,  0.275, 0.345 ], // Qt::Key_G,       
            [  8, 0.20,  0.32,  0.275, 0.345 ], // Qt::Key_H,       
            [  9, 0.345, 0.47,  0.275, 0.345 ], // Qt::Key_I,       
            [ 10, 0.52,  0.63,  0.275, 0.345 ], // Qt::Key_J,       
            [ 11, 0.68,  0.80,  0.275, 0.345 ], // Qt::Key_K,       
            [ 12, 0.83,  0.95,  0.275, 0.345 ], // Qt::Key_L,       
        
            [ 13, 0.03,  0.32,  0.40,  0.47  ], // Qt::Key_Return,  
            [ 14, 0.345, 0.47,  0.40,  0.47  ], // Qt::Key_M,       
            [ 15, 0.51,  0.64,  0.40,  0.47  ], // Qt::Key_N,       
            [ 16, 0.68,  0.80,  0.40,  0.47  ], // Qt::Key_O,       
            [ 17, 0.83,  0.95,  0.40,  0.47  ], // Qt::Key_Backspace
        
            [ 18, 0.03,  0.15,  0.52,  0.59  ], // Qt::Key_Up,      
            [ 19, 0.23,  0.36,  0.52,  0.59  ], // Qt::Key_7,       
            [ 20, 0.42,  0.56,  0.52,  0.59  ], // Qt::Key_8,       
            [ 21, 0.62,  0.75,  0.52,  0.59  ], // Qt::Key_9,       
            [ 22, 0.81,  0.95,  0.52,  0.59  ], // Qt::Key_Slash,   
        
            [ 23, 0.03,  0.15,  0.645, 0.715 ], // Qt::Key_Down,    
            [ 24, 0.23,  0.36,  0.645, 0.715 ], // Qt::Key_4,       
            [ 25, 0.42,  0.56,  0.645, 0.715 ], // Qt::Key_5,       
            [ 26, 0.62,  0.75,  0.645, 0.715 ], // Qt::Key_6,       
            [ 27, 0.81,  0.95,  0.645, 0.715 ], // Qt::Key_Asterisk,
        
            [ 28, 0.028, 0.145, 0.77,  0.84  ], // Qt::Key_Control, 
            [ 29, 0.23,  0.36,  0.77,  0.84  ], // Qt::Key_1,       
            [ 30, 0.42,  0.56,  0.77,  0.84  ], // Qt::Key_2,       
            [ 31, 0.62,  0.75,  0.77,  0.84  ], // Qt::Key_3,       
            [ 32, 0.81,  0.95,  0.77,  0.84  ], // Qt::Key_Minus,   
        
            [ 33, 0.03,  0.15,  0.89,  0.97  ], // Qt::Key_Escape,  
            [ 34, 0.23,  0.36,  0.89,  0.97  ], // Qt::Key_0,       
            [ 35, 0.42,  0.55,  0.89,  0.97  ], // Qt::Key_Period,  
            [ 36, 0.62,  0.74,  0.89,  0.97  ], // Qt::Key_Question,
            [ 37, 0.81,  0.95,  0.89,  0.97  ], // Qt::Key_Plus,    
        ];

        // canvas for the keyboard
        const canvas_key = document.getElementById('keyCanvas');
        const KEY_H = SIM_LCD_SCANLINE * KB_RATIO;
        const KEY_W = SIM_LCD_SCANLINE - SIM_LCD_OFFSET;
        canvas_key.width  = KEY_W;
        canvas_key.height = KEY_H;
        const ctx_key = canvas_key.getContext('2d');        
        ctx_key.clearRect( 0, 0, KEY_W, KEY_H);
        // debug presses
        if (DEBUG) {
          ctx_key.strokeStyle = "red";
          for (let i=0; i<key_map.length; i++) {
            ctx_key.beginPath();
            ctx_key.moveTo(key_map[i][1]*KEY_W, key_map[i][3]*KEY_H);
            ctx_key.lineTo(key_map[i][1]*KEY_W, key_map[i][4]*KEY_H);
            ctx_key.lineTo(key_map[i][2]*KEY_W, key_map[i][4]*KEY_H);
            ctx_key.lineTo(key_map[i][2]*KEY_W, key_map[i][3]*KEY_H);
            ctx_key.lineTo(key_map[i][1]*KEY_W, key_map[i][3]*KEY_H);
            ctx_key.stroke();
          }
        }

        // get the mouse/touch position
        const getMousePosition = function(canvas, event) {
            let rect = canvas.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;
            if (DEBUG) {
              console.log("clicked x: " + x, " y: " + y);
            }
            // should use html elements for the keys in future
            for (let i=0; i<key_map.length; i++) {
              if (x > key_map[i][1]*KEY_W && x < key_map[i][2]*KEY_W && y > key_map[i][3]*KEY_H && y < key_map[i][4]*KEY_H) {
                console.log("clicked:", key_map[i][0]);
                Module.ui_push_key(key_map[i][0]);
                Module.ui_push_key(0);
                Module.run_rpl(); // don't think this is needed
              }
            }
        }
        
        // add an event listener to the canvas so we can parse the key presses
        canvas_key.addEventListener("mousedown", function (e) {
            getMousePosition(canvas_key, e);
        }); 

        // draw the LCD panel
        const canvas = document.getElementById('lcdCanvas');
        canvas.width = SIM_LCD_SCANLINE - SIM_LCD_OFFSET;
        canvas.height = SIM_LCD_H;
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(canvas.width, canvas.height);

        // parse the LCD data and draw to the canvas
        const drawBitmap = function(canvasId, dataArray, width, height) {
          const canvas = document.getElementById(canvasId);
          const ctx = canvas.getContext('2d');
          
          canvas.width = SIM_LCD_SCANLINE - SIM_LCD_OFFSET;
          canvas.height = SIM_LCD_H;
          
          const imageData = ctx.createImageData(width, height);
          const data = imageData.data;

          for (let i = 0; i < dataArray.length; i++) {
              const bitmask = dataArray[i];
              for (let bit = 0; bit < 32; bit++) {
                  const value = (bitmask >> bit) & 1;
                  const pixelIndex = i * 32 + bit;
                  const x = pixelIndex % width;
                  const y = Math.floor(pixelIndex / width);
                  const mirroredX = width - 1 - x; // Mirroring the x position
                  const index = (y * width + mirroredX) * 4;
                  // const index = (y * width + x) * 4;

                  const color = value === 1 ? 213 : 0;
                  data[index] = color;
                  data[index + 1] = color;
                  data[index + 2] = color;
                  data[index + 3] = 255; // Alpha channel
              }
          }

          // offset -16 pixels to the left
          ctx.putImageData(imageData, -SIM_LCD_OFFSET, 0);
        }

      
      Module.onRuntimeInitialized = function() {

        // initialise the calculator
        console.log("loaded wasm...");
        console.log("init_all_elements()",Module.init_all_elements());

        // fetch and display the LCD
        const getLCD = function() {
          var heap = Module.updatePixmap();
          const lcd_buffer = []
          for (let v=0; v < (13*240); v++) {
            lcd_buffer.push( Module.HEAP32[heap/Int32Array.BYTES_PER_ELEMENT+v] )
          }
          drawBitmap('lcdCanvas', lcd_buffer, SIM_LCD_SCANLINE, SIM_LCD_H);
        }

        // run the lcd thread
        const lcdThread = setInterval(()=>{
          getLCD();
        }, 100);
        
        // run the rpl thread
        const rpnThread = setInterval(()=>{
          Module.run_rpl();
        }, 100);

        // both threads should run on a requestAnimationFrame() - future use
        // const step = function(timeStamp) {
        //   getLCD();
        //   // Module.run_rpl()
        //   window.requestAnimationFrame(step);
        // }
        // window.requestAnimationFrame(step);
        
      }
    </script>

  </body>
</html>
